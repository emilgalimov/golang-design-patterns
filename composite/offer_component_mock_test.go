package main

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/emilgalimov/golang-design-patterns/composite.offerComponent -o ./composite/offer_component_mock_test.go -n ComponentMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ComponentMock implements offerComponent
type ComponentMock struct {
	t minimock.Tester

	funcID          func() (i1 int)
	inspectFuncID   func()
	afterIDCounter  uint64
	beforeIDCounter uint64
	IDMock          mComponentMockID

	funcIncreasePricePercent          func(i1 int)
	inspectFuncIncreasePricePercent   func(i1 int)
	afterIncreasePricePercentCounter  uint64
	beforeIncreasePricePercentCounter uint64
	IncreasePricePercentMock          mComponentMockIncreasePricePercent

	funcPrice          func() (i1 int)
	inspectFuncPrice   func()
	afterPriceCounter  uint64
	beforePriceCounter uint64
	PriceMock          mComponentMockPrice
}

// NewComponentMock returns a mock for offerComponent
func NewComponentMock(t minimock.Tester) *ComponentMock {
	m := &ComponentMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IDMock = mComponentMockID{mock: m}

	m.IncreasePricePercentMock = mComponentMockIncreasePricePercent{mock: m}
	m.IncreasePricePercentMock.callArgs = []*ComponentMockIncreasePricePercentParams{}

	m.PriceMock = mComponentMockPrice{mock: m}

	return m
}

type mComponentMockID struct {
	mock               *ComponentMock
	defaultExpectation *ComponentMockIDExpectation
	expectations       []*ComponentMockIDExpectation
}

// ComponentMockIDExpectation specifies expectation struct of the offerComponent.ID
type ComponentMockIDExpectation struct {
	mock *ComponentMock

	results *ComponentMockIDResults
	Counter uint64
}

// ComponentMockIDResults contains results of the offerComponent.ID
type ComponentMockIDResults struct {
	i1 int
}

// Expect sets up expected params for offerComponent.ID
func (mmID *mComponentMockID) Expect() *mComponentMockID {
	if mmID.mock.funcID != nil {
		mmID.mock.t.Fatalf("ComponentMock.ID mock is already set by Set")
	}

	if mmID.defaultExpectation == nil {
		mmID.defaultExpectation = &ComponentMockIDExpectation{}
	}

	return mmID
}

// Inspect accepts an inspector function that has same arguments as the offerComponent.ID
func (mmID *mComponentMockID) Inspect(f func()) *mComponentMockID {
	if mmID.mock.inspectFuncID != nil {
		mmID.mock.t.Fatalf("Inspect function is already set for ComponentMock.ID")
	}

	mmID.mock.inspectFuncID = f

	return mmID
}

// Return sets up results that will be returned by offerComponent.ID
func (mmID *mComponentMockID) Return(i1 int) *ComponentMock {
	if mmID.mock.funcID != nil {
		mmID.mock.t.Fatalf("ComponentMock.ID mock is already set by Set")
	}

	if mmID.defaultExpectation == nil {
		mmID.defaultExpectation = &ComponentMockIDExpectation{mock: mmID.mock}
	}
	mmID.defaultExpectation.results = &ComponentMockIDResults{i1}
	return mmID.mock
}

//Set uses given function f to mock the offerComponent.ID method
func (mmID *mComponentMockID) Set(f func() (i1 int)) *ComponentMock {
	if mmID.defaultExpectation != nil {
		mmID.mock.t.Fatalf("Default expectation is already set for the offerComponent.ID method")
	}

	if len(mmID.expectations) > 0 {
		mmID.mock.t.Fatalf("Some expectations are already set for the offerComponent.ID method")
	}

	mmID.mock.funcID = f
	return mmID.mock
}

// ID implements offerComponent
func (mmID *ComponentMock) ID() (i1 int) {
	mm_atomic.AddUint64(&mmID.beforeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmID.afterIDCounter, 1)

	if mmID.inspectFuncID != nil {
		mmID.inspectFuncID()
	}

	if mmID.IDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmID.IDMock.defaultExpectation.Counter, 1)

		mm_results := mmID.IDMock.defaultExpectation.results
		if mm_results == nil {
			mmID.t.Fatal("No results are set for the ComponentMock.ID")
		}
		return (*mm_results).i1
	}
	if mmID.funcID != nil {
		return mmID.funcID()
	}
	mmID.t.Fatalf("Unexpected call to ComponentMock.ID.")
	return
}

// IDAfterCounter returns a count of finished ComponentMock.ID invocations
func (mmID *ComponentMock) IDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmID.afterIDCounter)
}

// IDBeforeCounter returns a count of ComponentMock.ID invocations
func (mmID *ComponentMock) IDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmID.beforeIDCounter)
}

// MinimockIDDone returns true if the count of the ID invocations corresponds
// the number of defined expectations
func (m *ComponentMock) MinimockIDDone() bool {
	for _, e := range m.IDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcID != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockIDInspect logs each unmet expectation
func (m *ComponentMock) MinimockIDInspect() {
	for _, e := range m.IDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ComponentMock.ID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		m.t.Error("Expected call to ComponentMock.ID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcID != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		m.t.Error("Expected call to ComponentMock.ID")
	}
}

type mComponentMockIncreasePricePercent struct {
	mock               *ComponentMock
	defaultExpectation *ComponentMockIncreasePricePercentExpectation
	expectations       []*ComponentMockIncreasePricePercentExpectation

	callArgs []*ComponentMockIncreasePricePercentParams
	mutex    sync.RWMutex
}

// ComponentMockIncreasePricePercentExpectation specifies expectation struct of the offerComponent.IncreasePricePercent
type ComponentMockIncreasePricePercentExpectation struct {
	mock   *ComponentMock
	params *ComponentMockIncreasePricePercentParams

	Counter uint64
}

// ComponentMockIncreasePricePercentParams contains parameters of the offerComponent.IncreasePricePercent
type ComponentMockIncreasePricePercentParams struct {
	i1 int
}

// Expect sets up expected params for offerComponent.IncreasePricePercent
func (mmIncreasePricePercent *mComponentMockIncreasePricePercent) Expect(i1 int) *mComponentMockIncreasePricePercent {
	if mmIncreasePricePercent.mock.funcIncreasePricePercent != nil {
		mmIncreasePricePercent.mock.t.Fatalf("ComponentMock.IncreasePricePercent mock is already set by Set")
	}

	if mmIncreasePricePercent.defaultExpectation == nil {
		mmIncreasePricePercent.defaultExpectation = &ComponentMockIncreasePricePercentExpectation{}
	}

	mmIncreasePricePercent.defaultExpectation.params = &ComponentMockIncreasePricePercentParams{i1}
	for _, e := range mmIncreasePricePercent.expectations {
		if minimock.Equal(e.params, mmIncreasePricePercent.defaultExpectation.params) {
			mmIncreasePricePercent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreasePricePercent.defaultExpectation.params)
		}
	}

	return mmIncreasePricePercent
}

// Inspect accepts an inspector function that has same arguments as the offerComponent.IncreasePricePercent
func (mmIncreasePricePercent *mComponentMockIncreasePricePercent) Inspect(f func(i1 int)) *mComponentMockIncreasePricePercent {
	if mmIncreasePricePercent.mock.inspectFuncIncreasePricePercent != nil {
		mmIncreasePricePercent.mock.t.Fatalf("Inspect function is already set for ComponentMock.IncreasePricePercent")
	}

	mmIncreasePricePercent.mock.inspectFuncIncreasePricePercent = f

	return mmIncreasePricePercent
}

// Return sets up results that will be returned by offerComponent.IncreasePricePercent
func (mmIncreasePricePercent *mComponentMockIncreasePricePercent) Return() *ComponentMock {
	if mmIncreasePricePercent.mock.funcIncreasePricePercent != nil {
		mmIncreasePricePercent.mock.t.Fatalf("ComponentMock.IncreasePricePercent mock is already set by Set")
	}

	if mmIncreasePricePercent.defaultExpectation == nil {
		mmIncreasePricePercent.defaultExpectation = &ComponentMockIncreasePricePercentExpectation{mock: mmIncreasePricePercent.mock}
	}

	return mmIncreasePricePercent.mock
}

//Set uses given function f to mock the offerComponent.IncreasePricePercent method
func (mmIncreasePricePercent *mComponentMockIncreasePricePercent) Set(f func(i1 int)) *ComponentMock {
	if mmIncreasePricePercent.defaultExpectation != nil {
		mmIncreasePricePercent.mock.t.Fatalf("Default expectation is already set for the offerComponent.IncreasePricePercent method")
	}

	if len(mmIncreasePricePercent.expectations) > 0 {
		mmIncreasePricePercent.mock.t.Fatalf("Some expectations are already set for the offerComponent.IncreasePricePercent method")
	}

	mmIncreasePricePercent.mock.funcIncreasePricePercent = f
	return mmIncreasePricePercent.mock
}

// IncreasePricePercent implements offerComponent
func (mmIncreasePricePercent *ComponentMock) IncreasePricePercent(i1 int) {
	mm_atomic.AddUint64(&mmIncreasePricePercent.beforeIncreasePricePercentCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreasePricePercent.afterIncreasePricePercentCounter, 1)

	if mmIncreasePricePercent.inspectFuncIncreasePricePercent != nil {
		mmIncreasePricePercent.inspectFuncIncreasePricePercent(i1)
	}

	mm_params := &ComponentMockIncreasePricePercentParams{i1}

	// Record call args
	mmIncreasePricePercent.IncreasePricePercentMock.mutex.Lock()
	mmIncreasePricePercent.IncreasePricePercentMock.callArgs = append(mmIncreasePricePercent.IncreasePricePercentMock.callArgs, mm_params)
	mmIncreasePricePercent.IncreasePricePercentMock.mutex.Unlock()

	for _, e := range mmIncreasePricePercent.IncreasePricePercentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmIncreasePricePercent.IncreasePricePercentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreasePricePercent.IncreasePricePercentMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreasePricePercent.IncreasePricePercentMock.defaultExpectation.params
		mm_got := ComponentMockIncreasePricePercentParams{i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreasePricePercent.t.Errorf("ComponentMock.IncreasePricePercent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmIncreasePricePercent.funcIncreasePricePercent != nil {
		mmIncreasePricePercent.funcIncreasePricePercent(i1)
		return
	}
	mmIncreasePricePercent.t.Fatalf("Unexpected call to ComponentMock.IncreasePricePercent. %v", i1)

}

// IncreasePricePercentAfterCounter returns a count of finished ComponentMock.IncreasePricePercent invocations
func (mmIncreasePricePercent *ComponentMock) IncreasePricePercentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreasePricePercent.afterIncreasePricePercentCounter)
}

// IncreasePricePercentBeforeCounter returns a count of ComponentMock.IncreasePricePercent invocations
func (mmIncreasePricePercent *ComponentMock) IncreasePricePercentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreasePricePercent.beforeIncreasePricePercentCounter)
}

// Calls returns a list of arguments used in each call to ComponentMock.IncreasePricePercent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreasePricePercent *mComponentMockIncreasePricePercent) Calls() []*ComponentMockIncreasePricePercentParams {
	mmIncreasePricePercent.mutex.RLock()

	argCopy := make([]*ComponentMockIncreasePricePercentParams, len(mmIncreasePricePercent.callArgs))
	copy(argCopy, mmIncreasePricePercent.callArgs)

	mmIncreasePricePercent.mutex.RUnlock()

	return argCopy
}

// MinimockIncreasePricePercentDone returns true if the count of the IncreasePricePercent invocations corresponds
// the number of defined expectations
func (m *ComponentMock) MinimockIncreasePricePercentDone() bool {
	for _, e := range m.IncreasePricePercentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreasePricePercentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreasePricePercentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreasePricePercent != nil && mm_atomic.LoadUint64(&m.afterIncreasePricePercentCounter) < 1 {
		return false
	}
	return true
}

// MinimockIncreasePricePercentInspect logs each unmet expectation
func (m *ComponentMock) MinimockIncreasePricePercentInspect() {
	for _, e := range m.IncreasePricePercentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ComponentMock.IncreasePricePercent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreasePricePercentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreasePricePercentCounter) < 1 {
		if m.IncreasePricePercentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ComponentMock.IncreasePricePercent")
		} else {
			m.t.Errorf("Expected call to ComponentMock.IncreasePricePercent with params: %#v", *m.IncreasePricePercentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreasePricePercent != nil && mm_atomic.LoadUint64(&m.afterIncreasePricePercentCounter) < 1 {
		m.t.Error("Expected call to ComponentMock.IncreasePricePercent")
	}
}

type mComponentMockPrice struct {
	mock               *ComponentMock
	defaultExpectation *ComponentMockPriceExpectation
	expectations       []*ComponentMockPriceExpectation
}

// ComponentMockPriceExpectation specifies expectation struct of the offerComponent.Price
type ComponentMockPriceExpectation struct {
	mock *ComponentMock

	results *ComponentMockPriceResults
	Counter uint64
}

// ComponentMockPriceResults contains results of the offerComponent.Price
type ComponentMockPriceResults struct {
	i1 int
}

// Expect sets up expected params for offerComponent.Price
func (mmPrice *mComponentMockPrice) Expect() *mComponentMockPrice {
	if mmPrice.mock.funcPrice != nil {
		mmPrice.mock.t.Fatalf("ComponentMock.Price mock is already set by Set")
	}

	if mmPrice.defaultExpectation == nil {
		mmPrice.defaultExpectation = &ComponentMockPriceExpectation{}
	}

	return mmPrice
}

// Inspect accepts an inspector function that has same arguments as the offerComponent.Price
func (mmPrice *mComponentMockPrice) Inspect(f func()) *mComponentMockPrice {
	if mmPrice.mock.inspectFuncPrice != nil {
		mmPrice.mock.t.Fatalf("Inspect function is already set for ComponentMock.Price")
	}

	mmPrice.mock.inspectFuncPrice = f

	return mmPrice
}

// Return sets up results that will be returned by offerComponent.Price
func (mmPrice *mComponentMockPrice) Return(i1 int) *ComponentMock {
	if mmPrice.mock.funcPrice != nil {
		mmPrice.mock.t.Fatalf("ComponentMock.Price mock is already set by Set")
	}

	if mmPrice.defaultExpectation == nil {
		mmPrice.defaultExpectation = &ComponentMockPriceExpectation{mock: mmPrice.mock}
	}
	mmPrice.defaultExpectation.results = &ComponentMockPriceResults{i1}
	return mmPrice.mock
}

//Set uses given function f to mock the offerComponent.Price method
func (mmPrice *mComponentMockPrice) Set(f func() (i1 int)) *ComponentMock {
	if mmPrice.defaultExpectation != nil {
		mmPrice.mock.t.Fatalf("Default expectation is already set for the offerComponent.Price method")
	}

	if len(mmPrice.expectations) > 0 {
		mmPrice.mock.t.Fatalf("Some expectations are already set for the offerComponent.Price method")
	}

	mmPrice.mock.funcPrice = f
	return mmPrice.mock
}

// Price implements offerComponent
func (mmPrice *ComponentMock) Price() (i1 int) {
	mm_atomic.AddUint64(&mmPrice.beforePriceCounter, 1)
	defer mm_atomic.AddUint64(&mmPrice.afterPriceCounter, 1)

	if mmPrice.inspectFuncPrice != nil {
		mmPrice.inspectFuncPrice()
	}

	if mmPrice.PriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrice.PriceMock.defaultExpectation.Counter, 1)

		mm_results := mmPrice.PriceMock.defaultExpectation.results
		if mm_results == nil {
			mmPrice.t.Fatal("No results are set for the ComponentMock.Price")
		}
		return (*mm_results).i1
	}
	if mmPrice.funcPrice != nil {
		return mmPrice.funcPrice()
	}
	mmPrice.t.Fatalf("Unexpected call to ComponentMock.Price.")
	return
}

// PriceAfterCounter returns a count of finished ComponentMock.Price invocations
func (mmPrice *ComponentMock) PriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrice.afterPriceCounter)
}

// PriceBeforeCounter returns a count of ComponentMock.Price invocations
func (mmPrice *ComponentMock) PriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrice.beforePriceCounter)
}

// MinimockPriceDone returns true if the count of the Price invocations corresponds
// the number of defined expectations
func (m *ComponentMock) MinimockPriceDone() bool {
	for _, e := range m.PriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPriceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrice != nil && mm_atomic.LoadUint64(&m.afterPriceCounter) < 1 {
		return false
	}
	return true
}

// MinimockPriceInspect logs each unmet expectation
func (m *ComponentMock) MinimockPriceInspect() {
	for _, e := range m.PriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ComponentMock.Price")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPriceCounter) < 1 {
		m.t.Error("Expected call to ComponentMock.Price")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrice != nil && mm_atomic.LoadUint64(&m.afterPriceCounter) < 1 {
		m.t.Error("Expected call to ComponentMock.Price")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ComponentMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIDInspect()

		m.MinimockIncreasePricePercentInspect()

		m.MinimockPriceInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ComponentMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ComponentMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIDDone() &&
		m.MinimockIncreasePricePercentDone() &&
		m.MinimockPriceDone()
}
